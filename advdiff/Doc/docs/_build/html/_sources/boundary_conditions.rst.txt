Boundary conditions
===================

As with solving any ODE or PDE, the choice of boundary conditions (BCs) is very important.
In the config file :doc:`setup.ini <./setup>`, the user is allowed to choose between 4 different 
boundary conditions: **Robin BCs**, **Neumann BCs**, **No flux BCs** and **Dirichlet BCs**, with the Robin BCs as the default option.

For the best results, Robin should be used. The Robin BC allows tracer to be removed from the system if it wanders outside the local grid, 
without being able to move back in. As such, the total mass of the system can never go beyond the theoretical maximum, as can happen with the Neumann BC.

.. note::

   At the moment, there is an experimental boundary condition called **Robin Experimental**. 
   It is a different implementation of the Robin BCs that is more consistent with
   the implementation in the FiPy documentation. However we found that it is less stable than the default Robin BC that we provide by default.



Comparing the different boundary conditions
---------------------------------------------

The first figure shown below displays a grid describing the behaviour of the exact same system with four different boundary conditions.
The second figure shows the respective total masses of each system.

.. figure:: .//images//Boundaries//boundary_conditions_comparison.gif
   :width: 75 %
   :align: center

   Comparison of the same scenario with different boundary conditions.


.. image:: .//images//Boundaries//mass_total_Robin.png
   :width: 45 %
.. image:: .//images//Boundaries//mass_total_Neumann.png
   :width: 45 %
.. image:: .//images//Boundaries//mass_total_no_flux.png
   :width: 45 %
.. image:: .//images//Boundaries//mass_total_Dirichlet.png
   :width: 45 %

* In the Robin case, some of the tracer is lost through the boundaries of the local grids. The lost mass never re-enters through the boundaries even as the velocity reverses. 
  As such, the total mass of the system can only decrease below the maximal theoretical limit. 


* In the Neumann case, some of the tracer is lost through the boundaries, however new mass is being generated by the boundaries once the velocity reverses.
  Hence, the total mass of the system can increase above the maximal theoretical limit which is unphysical.


* In the No flux case, the boundaries are treated as walls. This means no tracer can leave or enter through the boundaries. The boundaries become an aggregation zones
  for which the tracer can get stuck.
  The total mass of the system perfectly aligns with the maximal theoretical limit, as no mass is either lost or gained over time.


* In the Dirichlet case, the system behaves quite strangely and unlike what I would have expected. 
  The Dirichlet condition behaves mostly like the Neumann one, but with certain points for which it behaves similarly to the no-flux case.
  I am not sure if this is a bug and what is the cause for the discrepancies we can see.
  Therefore I do not recommend using the Diriclet BC.
  This needs to be investigated further.



Robin boundary conditions
--------------------------

It seems that the default way of applying Robin BCs in the `FiPy documentation <https://www.ctcms.nist.gov/fipy/documentation/USAGE.html#boundary-conditions>`_ does not work too well for the AdvDiff module. 
Instead, I found an alternate way of getting it to work the way that I wanted. I borrowed ideas from the following links: 
`Link 1 <https://www.ctcms.nist.gov/fipy/examples/convection/generated/examples.convection.robin.html>`_,
`Link 2 <https://github.com/usnistgov/fipy/issues/426>`_,
`Link 3 <https://github.com/usnistgov/fipy/issues/788>`_,
`Link 4 <https://github.com/usnistgov/fipy/blob/8efb4378648c339a710ce021fb5e0c25a1899b4e/examples/convection/robin.py>`_.

The basic outline of how it is implemented is shown below: 

.. code-block:: python

   self.tracer = fp.CellVariable(name = 'tracer', mesh = self.mesh, value = 0.) # Initialize the tracer

   np.seterr(divide='ignore', invalid='ignore')                       # Since D is constrained to 0 on the boundaries, numpy likes to print warnings about dividing by 0. I want to ignore this...
   DC = 1.0                                                           # Arbitrary dampening constant for how quickly tracer is dampened at the boundaries                                      
   self.velocity.constrain(0., where=self.mesh.exteriorFaces)         # To get Robin to work, I had to use ImplicitSourceTerms
   self.D.constrain(0.,        where=self.mesh.exteriorFaces)         # This means constraining D and v along the boundaries and letting sources along boundaries drive the behaviour along the boundary.
   self._BC_SourceTerm = fp.ImplicitSourceTerm(var=self.tracer, coeff=-DC*(self.mesh.exteriorFaces * self.mesh.faceNormals).divergence)

   self.eq = (self._TransientTerm + self._ConvectionTerm == self._DiffusionTerm + self._SourceTerm + self._BC_SourceTerm) # Assemble PDE with BC term



Neumann boundary conditions
----------------------------


The Neumann BC is straight forward to implement and it follows the typical FiPy convention..

.. code-block:: python

   self.tracer = fp.CellVariable(name = 'tracer', mesh = self.mesh, value = 0.) # Initialize the tracer
   self.tracer.faceGrad.constrain(0.0, where=self.mesh.exteriorFaces)           # Neumann BC



No flux boundary conditions
----------------------------


As described in the `FiPy documentation <https://www.ctcms.nist.gov/fipy/documentation/USAGE.html#boundary-conditions>`_, the no flux BC is the default BC. 
As such, no constraints were needed to implement it.

.. code-block:: python

   self.tracer = fp.CellVariable(name = 'tracer', mesh = self.mesh, value = 0.) # Initialize the tracer



Dirichlet boundary conditions
------------------------------


The Dirichlet BC was implemented as described in the `FiPy documentation <https://www.ctcms.nist.gov/fipy/documentation/USAGE.html#boundary-conditions>`_, 
however it still behaves strangely. This needs to be investigated further...

.. code-block:: python

   self.tracer.constrain(0.0, where=self.mesh.exteriorFaces) # Dirichlet BC

